# ECE1778: React Native for Mobile Device Applications



## Lecture 1: 

### Environment Setup

- IOS Simulator:

  1. On MacOS, install Xcode
  2. Important, in Xcode, must open settings -> Component -> Install Platforms, otherwise simulator does not have platform to choose from, and **no error nor indicator**.
  3. `open -a Simulator` in terminal to open simulator

- Android Simulator:

  - [Android  Studio](https://developer.android.com/studio) 
  - [install essentials for AS emulator](https://docs.expo.dev/workflow/android-studio-emulator/#install-watchman-and-jdk)
  
- npx end:

  ```sh
  npx create-expo-app@latest <app_name> --blank
  cd <app_name>
  npx expo start --localhost  # --localhost` is very important
  ```
  
  
  





## Lecture 2: 2025/09/10



- The reason why React Native can work on both IOS and Android is because React Native will translate JS and React into IOS and Android Native elements.



- Most common React Native components:

  ```jsx
  <view>
  
  <Text>
  
  <Button>
  ```



### Flexbox

- React Native uses Flexbox for positioning elements, by default the flexDirection is column, meaning it will flex vertically.

- **READ THIS FLEXBOX style**: Doc: https://reactnative.dev/docs/flexbox



### Styling `StyleSheet.create()`

- Use `StyleSheet` for better organization:

  ```js
  import { Button, StyleSheet, Text, View } from "react-native";
  
  const styles = StyleSheet.create({
  
  })
  ```



- `StyleSheet.create` **has performance optimization**, the item in the Json will only created once and cached, making future use faster.



### All React Native Components

​	https://reactnative.dev/docs/button 



### Display a List of Items

- `ScrollView`: you can scroll, **has limitations**, will display all items at once, good for small list
- `FlatList`: **Solution** to too much items to display, will render only visible items.





### Dynamic Island

- The top of the screen is blocked by the Dynamic Island. To make things work automatically with DI, use SafeAreaProvider.

  `npm install react-native-safe-area-context` 

  ```js
  import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context"
  
  return (
   <SafeAreaProvider>
     <SafeAreaView>
     	<Text>Page content</Text>
     </SafeAreaView>
   </SafeAreaProvider>
  );
  ```



### Alert `Alert.alert()`

- Use `Alert.alert()` to prompt for change and errors.

  ```js
  import React from 'react';
  import {StyleSheet, Button, Alert} from 'react-native';
  import {SafeAreaView, SafeAreaProvider} from 'react-native-safe-area-context';
  
  const App = () => {
    const createTwoButtonAlert = () =>
      Alert.alert('Alert Title', 'My Alert Msg', [
        {
          text: 'Cancel',
          onPress: () => console.log('Cancel Pressed'),
          style: 'cancel',
        },
        {text: 'OK', onPress: () => console.log('OK Pressed')},
      ]);
  
    return (
      <SafeAreaProvider>
        <SafeAreaView style={styles.container}>
          <Button title={'2-Button Alert'} onPress={createTwoButtonAlert} />
        </SafeAreaView>
      </SafeAreaProvider>
    );
  };
  
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'space-around',
      alignItems: 'center',
    },
  });
  
  export default App;
  ```

  









## Lecture 3: 2025/09/17



### Why `StyleSheet`?

- **Performance**: Styles are cached in the native layer
- **Readability**: Centralized style definitions
- **Maintainability**: Easy to reuse across components





### ``StyleSheet.compose()``

Return an Array of styles, combines input style1 and style2, with style2 as priority. Handle null input.

```typescript
static compose(style1: Object, style2: Object): Object | Object[];
```

- Returns `style1`, `style2`, `[style1, style2]`, or `null`, depending on which is null
- If both are defined, `style2` overrides any conflicts from `style1`

We can actually use `**const** container = [page.container, lists.listContainer];`, but compose do extra checks. **so just always use `StyleSheet.compose()`**





### `StyleSheet.flatten()`

Combine an Array of styles into a single one.

```js
const page = StyleSheet.create({
  container: { flex: 1, backgroundColor: "white" },
});

const lists = StyleSheet.create({
  listContainer: { backgroundColor: "skyblue" },
});

const container = StyleSheet.flatten([page.container, lists.listContainer]);
```



Create a new style object

```js
{
  "flex": 1,
  "backgroundColor": "skyblue"
}
```





#### StyleSheet: Rule of Thumb

- Final product / UI rendering: Use `compose()` or an array of styles
- Debugging / needing raw values: Use `flatten()`



### Separate color code in alternative file

- Separation of concerns:
  - `styles/`: Define how components look (layout, spacing, text styles)
  - `constants/`: Store reusable values used across app
- Reusability: Colors can be used in styles, components, or even logic (e.g., status-based coloring)

Example Project Structure
```
project-root/
├── App.tsx
├── constants/
│   ├── colors.ts
│   └── fonts.ts
├── styles/
│   └── globalStyles.ts
```

`colors.ts`: Example

```ts
// constants/colors.ts
export const colors = {
  primary: "#4CAF50",
  secondary: "#FFC107",
  background: "#F5F5F7",
  titleText: "#8A646E",
  text: "#333",
  error: "#F44336",
};
```







### Flexbox: Core Properties

**Container Properties**

- `flexDirection`: Direction of main axis
  
  - `"column"` (default): Children stacked vertically
  
  - `"row"`: Children stacked horizontally
  
    

![flexdirection](assets/flexdirection.svg)



- `justifyContent`: Align children along **main axis**
  - `flex-start` (default): Start of main axis
  - `center`: Center of main axis
  - `space-between`: Evenly spaced across main axis
  - …
- `alignItems`: Align children along **cross axis**
  - Also has `flex-start` `center` `space-between`...




**Child Properties**

- `flex`: Proportion of space

  ```tsx
  <View style={[styles.container, { flexDirection: "column" }]}>
    <View style={{ flex: 1, backgroundColor: "red" }} />    // takes 1/6 space
    <View style={{ flex: 2, backgroundColor: "blue" }} />   // takes 2/6 space
    <View style={{ flex: 3, backgroundColor: "green" }} />  // takes 3/6 space
  </View>
  ```

- `width` / `height`: Fixed size is still respected
- `alignSelf`: Override `alignItems` for a single child







### `<Button>` 

`<Button>` has very limited customization, can only change button.



### `<Pressable>`

`<Pressable>`  is better than `<Button>`

- Full control over layout and appearance
- Can handle tap interaction (`onPress`)

  ```
  <Pressable onPress={() => console.log("Pressed!")} >
  	<Text>Click Me</Text>
  </Pressable>
  ```

- Can style for different states (`pressed`)
- `pressed`: Touch → `pressed` is `true`

  ```tsx
<Pressable
    style={({ pressed }) => [styles.button, pressed && styles.buttonPressed]}
    onPress={...}
  >
  ```

- Can Wrap another object, like `<Image>`

  ```tsx
  <Pressable onPress={() => Alert.alert("Image pressed!")}>
    <Image
      source={require("./assets/avatar.png")}
      style={{ width: 100, height: 100 }}
    />
  </Pressable>
  ```






### `<Image>`

- Use `source` prop: Currently support `png`, `jpg`, `jpeg`, `bmp`, `gif`, `webp`, `psd` (iOS only)

  - Local: `source={require("./assets/avatar.png")}`

  - Remote: `source={{ uri: "https://reactnative.dev/img/tiny_logo.png" }}`



### `<TouchableOpacity>`

A wrapper that dims the view when pressed

`<Pressable>` can replicate `TouchableOpacity` behavior using `pressed`



### `<Modal>`

A page that fully cover the current page.

Core Props:

- `visible` (boolean): Whether the modal is shown
- `onRequestClose` (function): Required on Android
  - Triggered when the system attempts to close the modal (e.g. back button)
- `animationType`: How modal appears/disappears
  - `"none"`, `"slide"`, `"fade"`
- `transparent` (boolean): Make background transparent



```tsx
<Modal
  visible={modalVisible}
  onRequestClose={() => setModalVisible(false)}
  animationType="slide"
  transparent={true}
>
  <Text>Hello from Modal</Text>
</Modal>
```







## Lecture 4: 2025/09/24

### Responsive design: portrait and landscape







### Light / Dark Mode

- Static (Bad, not responsive)

    ```ts
    import { Appearance } from "react-native";
    
    const colorScheme = Appearance.getColorScheme();
    console.log(colorScheme); // "light" or "dark"
    ```
    
- Reactive (React hook):

    ```tsx
    import { useColorScheme, View } from "react-native";
    
    export default function App() {
      const scheme = useColorScheme();  // hook on change theme
      return (
        <View style={{ backgroundColor: scheme === "dark" ? "#000" : "#fff" }} />
      );
    }
    ```

    







### Navigator

```bash
npm install @react-navigation/native
npx expo install react-native-screens react-native-safe-area-context
```



```ts
// screens/HomeScreen.tsx
import { View, Text } from "react-native";
import { globalStyles } from "../styles/globalStyles";

export default function HomeScreen() {
  return (
    <View style={globalStyles.container}>
      <Text style={globalStyles.headerText}>Home Screen</Text>
    </View>
  );
}

// screens/DetailsScreen
// similar to HomeScreen()

// App.tsx
import { createStaticNavigation } from "@react-navigation/native";
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import HomeScreen from "./screens/HomeScreen";
import DetailsScreen from "./screens/DetailsScreen";

const RootStack = createNativeStackNavigator({
  initialRouteName: "Home",
  screens: {
    Home: HomeScreen,
    Details: DetailsScreen,
  },
});

const Navigation = createStaticNavigation(RootStack);

export default function App() {
  return <Navigation />;
}
```









## Lecture 5: October 1, 2025

### Expo Router

#### Setup:

```sh
npx create-expo-app@latest --template blank-typescript

npx expo install expo-router react-native-safe-area-context react-native-screens expo-linking expo-constants expo-status-bar

# in package.json
{
  "main": "expo-router/entry",
}
```

Replace `App.tsx` with ` app/_layout.tsx` (Root layout)

​	TODO: `app.json`?



#### Expo Router Key Implementation 

- File-based routing: Screens are files inside app/ directory
- Built on React Navigation: Simpler setup
- Setup: Add dependencies, set `"main": "expo-router/entry"`, define a scheme
  - Navigation structure
    - `app/_layout.tsx` defines root `<Stack>` (`App.tsx`)
    - `app/index.tsx` defines initial route (`HomeScreen.tsx`)
- **Automatic types**: No need to define a type and pass to generic navigator. Expo Router infers route + param types from file structure
- **Navigation API**: Use the global `router.push("/path")` (vs. `navigation.navigate("Name")` in React Navigation)



Expo Router = React Navigation + file-based routing + automatic type safety



#### Dynamic Routes

Square brackets `[ ]` in filenames = dynamic routes

```tsx
app/details/[id].tsx
```

- `/details/1`→ opens `app/details/[id].tsx`
- `/details/abc` → also opens `app/details/[id].tsx`



```tsx
import { useLocalSearchParams } from "expo-router";

export default function Details() {
  // Read dynamic route parameters inside a screen
  const { id } = useLocalSearchParams();  // /details/12 → { id: "12" } (string)
  ...
}
  
```



```tsx
import { View, Text } from "react-native";
import { router } from "expo-router";
import { globalStyles } from "../styles/globalStyles";
import PrimaryButton from "../components/PrimaryButton";

export default function Home() {
  return (
    <View style={globalStyles.container}>
      <Text style={globalStyles.headerText}>Home Screen</Text>
      <PrimaryButton onPress={() => router.push("/details")}>
        Go to Details
      </PrimaryButton>
      {// Navigate with Param}
      <PrimaryButton onPress={() => router.push("/details/12")}>  
        Go to Details 12
      </PrimaryButton>
    </View>
  );
}
```



####  Expo Router Group

use () will make path hidden to URL path.

```sh
app/
 └── (tabs)/
      ├── profile.tsx
      └── settings.tsx
```

- URL `/profile` → `app/(tab)/profile.tsx`
- URL `/settings` → `app/(tab)/settings.tsx`





### Expo Router vs. React Navigation

| Feature          | React Navigation                          | Expo Router                   |
| :--------------- | :---------------------------------------- | :---------------------------- |
| Routing Style    | Manual config (e.g., `<Stack.Navigator>`) | File-based (`app/[id].tsx`)   |
| Setup Complexity | Explicit screens, params types            | Auto-routes, inferred types   |
| Navigation API   | `navigate("Name", params)`                | `router.push("/path")`        |
| Params           | `route.params`                            | `useLocalSearchParams()`      |
| Type Safety      | Manual `ParamList` definitions            | Automatic from file structure |





## Lecture 6: October 8, 2025

### State Managements

- **Context API**: Global state without prop drilling
- **`useReducer`**: Managing complex local state
- **Redux Toolkit**: Scalable global state for larger apps





### Context API

React’s built-in solution for sharing state across components

- **No external libraries**: Lightweight and always available in React/React Native
- **Wrap parts of your app**: Components inside this wrapper can access shared state directly
- **Ideal for**: Medium-sized apps or simple global data

[Context API Doc](https://react.dev/learn/passing-data-deeply-with-context)

#### Usage

1. **Create Context**

   ```
   const MyContext = createContext(defaultValue)
   ```

   - Define a shared “container” for state
   - Set an optional default value

2. **Provider**

   ```
   <MyContext.Provider value={someValue}>
     <ChildComponent />
   </MyContext.Provider>
   ```

   - Wrap components that should access the shared state
   - Pass the current value to all its descendants

3. **Consumer**

​	Use `useContext(MyContext)` to read or use the shared value inside any child component



#### Example

```tsx
import { createContext } from "react";

export type ThemeContextType = {
  theme: "light" | "dark";
  toggleTheme: () => void;
};

const ThemeContext = createContext<ThemeContextType>({
  theme: "light",
  toggleTheme: () => {},
});
```



#### Limitations:

Context API works well for simple global state (e.g., theme, user settings), but can become challenging as app grows:

- All consumers re-render on any change → May affect performance
- Not ideal for complex state logic → Better to use `useReducer` or Redux





### `useReducer`

Fine-grained operations than `useState`. When initialized `useReducer` you also define the operation on the state, the function is called the reducer. It limits on how you operate the state. `useState` you can update the state value however you want, but `useReducer` you can only use the pre-defined reducer function to operate the state.

#### Usage

```ts
import { useReducer } from "react";
import { View, Text, Button } from "react-native";

type State = { count: number };
type Action = { type: "increment" | "decrement" };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <View>
      <Text>Count: {state.count}</Text>
      <Button title="+" onPress={() => dispatch({ type: "increment" })} />
      <Button title="-" onPress={() => dispatch({ type: "decrement" })} />
    </View>
  );
}
```





## Lecture 7: October 15, 2025

### Redux Toolkit

Advanced global state management. The toolkit provides more tools than Redux itself. Each stored unit is "slice", rather than "store", which means a bundle of stored values and its operations, pretty much like how `useReducer` bundles operations than just `useState`.



#### Usage

Redux Toolkit is too hard to use, therefore I suggest to look at A4.

Example: Theme Switcher Flow

1. Create a slice with `createSlice`
2. Configure store with `configureStore`
3. Wrap app with `<Provider>`
4. Access state and trigger updates in components with `useSelector` + `useDispatch`





### Data Persistence: async-storage

#### Setup

```bash
# install with
npm install @react-native-async-storage/async-storage
# or
npx expo install @react-native-async-storage/async-storage
```



#### Store value

```js
import AsyncStorage from "@react-native-async-storage/async-storage";
```

- Each value is stored under a **unique string key**, reusing the same key **overwrites** the previous value
  - `await setItem(key, value)`: Store a string value
  - `await getItem(key)`: Retrieve a string value (or null if not found)
  - **All operations are asynchronous**. Always use `await` or `.then()` to handle results
- For complex data (arrays or objects), use JSON
  - `JSON.stringify()` when **saving**
  - `JSON.parse()` when **loading**



## Lecture 8: October 22, 2025

### Notification Types

| Type      | Triggered By      | Internet Required | Typical Use                       |
| :-------- | :---------------- | :---------------- | :-------------------------------- |
| **Local** | App (device-side) | No                | Reminders, timers, offline alerts |
| **Push**  | Server or backend | Yes               | Chat messages, live updates       |



### Notification via Expo Notifications

Expo provides a cross-platform API for **both local and push notifications**.

#### Setup

```sh
npx expo install expo-notifications
```

```js
import * as Notifications from "expo-notifications";

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowBanner: true, // Show notification as a banner/alert
    shouldShowList: true, // Add notification to system list/center for later viewing
    shouldPlaySound: true, // Play sound on arrival
    shouldSetBadge: false, // Do not update app icon badge count
  }),
});  

export default function App() {
  useEffect(() => {
    registerForNotifications();
  }, []);

  async function registerForNotifications() {
    const { status } = await Notifications.requestPermissionsAsync();
    if (status !== "granted") {
      Alert.alert("Permission not granted!");
      return;
    }
  }
}


```



#### Usage

Use `scheduleNotificationAsync()` to schedule a notification to be triggered in the future

```js
// sends a local notification 5 seconds after this code runs.
Notifications.scheduleNotificationAsync({
  content: { title: "Daily Reminder", body: "Time to check your app!" },
  trigger: {
    type: Notifications.SchedulableTriggerInputTypes.TIME_INTERVAL,
    seconds: 5,  
  },
});
```

Define event if user click the notification:

```js
useEffect(() => {
    const subscription = Notifications.addNotificationResponseReceivedListener(
      (response) => {
        console.log(
          "User tapped notification:",
          response.notification.request.content
        );
      }
    );

    return () => subscription.remove();  // useEffect() expects to return a cleaner function, to be called when component un-mounted
}, []);
```



#### Full Implementation Example

```js
import * as Notifications from "expo-notifications";
import { useEffect } from "react";
import { Alert, Button, View, StyleSheet } from "react-native";

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowBanner: true,
    shouldShowList: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});

export default function App() {
  useEffect(() => {
    registerForNotifications();
  }, []);

  useEffect(() => {
    const subscription = Notifications.addNotificationResponseReceivedListener(
      (response) => {
        console.log(
          "User tapped notification:",
          response.notification.request.content
        );
      }
    );

    return () => subscription.remove();
  }, []);

  async function registerForNotifications() {
    const { status } = await Notifications.requestPermissionsAsync();
    if (status !== "granted") {
      Alert.alert("Permission not granted!");
      return;
    }
  }

  async function scheduleNotification() {
    await Notifications.scheduleNotificationAsync({
      content: { title: "Daily Reminder", body: "Time to check your app!" },
      trigger: {
        type: Notifications.SchedulableTriggerInputTypes.TIME_INTERVAL,
        seconds: 5,
      },
    });
  }

  return (
    <View style={styles.container}>
      <Button title="Schedule Notification" onPress={scheduleNotification} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
});
```





### Expo Push Notification 

#### Push Notification Mechanism

1. User A sends a message → Your server receives it
2. Server looks up User B’s push token (stored in database)
3. Server tells Expo: “Send alert to token XYZ: ‘New message from A’”
4. Expo delivers to User B’s device → Notification appears

#### Setup

```sh
npx expo install expo-notifications expo-device expo-constants
```

In `app.json`, enable

```sh
{
  "expo": {
    "plugins": [
      "expo-notifications"
    ]
  }
}
```



#### Client Side Workflow

1. Request permissions (`Notifications.requestPermissionsAsync()`)
2. Fetch project ID from `expo-constants` (`Constants.expoConfig.extra.eas.projectId`)
3. Call `Notifications.getExpoPushTokenAsync({ projectId })`
4. Log or send token to server

```ts
import * as Notifications from "expo-notifications";
import Constants from "expo-constants";

async function getPushToken() {
  // Request permissions (same as local)
  await Notifications.requestPermissionsAsync();

  // Get token using project ID
  const projectId = Constants.expoConfig.extra.eas.projectId;
  const token = await Notifications.getExpoPushTokenAsync({ projectId });

  console.log("Token:", token.data); // Send this to your server
  return token.data;
}

// Call on app load: getPushToken();
```



#### Server Side Workflow

1. Server receives/stores user tokens
2. On event (e.g., new message), POST to Expo’s cloud endpoint with token + message
3. Expo’s service queues & forwards to device (via FCM/APNs)

```ts
async function sendPush(token) {
  const message = {
    to: token, // User's push token (as "address")
    sound: "default", // Play sound on arrival
    title: "New Message",
    body: "Hello from server!",
    data: { extra: "info" }, // Custom data for app handling
  };

  await fetch("https://exp.host/--/api/v2/push/send", {
    // Expo's cloud endpoint
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(message),
  });
}

// Usage: sendPush('ExponentPushToken[abc123...]');
```

**Tip**: Test sending push noticiations with [Expo’s Online Tool](https://expo.dev/notifications)

- Paste your token for quick delivery via Expo’s cloud



#### Client Listen for Events

```ts
// Add listeners (in useEffect)
useEffect(() => {
  const onReceive = Notifications.addNotificationReceivedListener(
    (notification) => {
      console.log("Push arrived:", notification);
      // Update UI/state
    }
  );

  const onTap = Notifications.addNotificationResponseReceivedListener(
    (response) => {
      console.log("Push tapped:", response);
      // Navigate to screen
    }
  );

  return () => {
    onReceive.remove();
    onTap.remove();
  }; // Cleanup
}, []);
```









## Lecture 9: November 5, 2025

### Integrate With Backend Using Supabase

Supabase: a BaaS provider.

Supabase JS API: <u>https://supabase.com/docs/reference/javascript/typescript-support</u>

#### Setup

```bash
npm install @supabase/supabase-js
```

Config `.env`

```bash
EXPO_PUBLIC_SUPABASE_URL=https://your-project-id.supabase.co
EXPO_PUBLIC_SUPABASE_PUBLIC_KEY=your-public-api-key
```

JS Configurations

```ts
// Supabase.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL as string;
const supabaseKey = process.env.EXPO_PUBLIC_SUPABASE_PUBLIC_KEY as string;
export const supabase = createClient(supabaseUrl, supabaseKey);
```

JS Configurations if Invoke SQL API

```sh
supabase gen types typescript --project-id abcdefghijklmnopqrst > database.types.ts
```

`database.types.ts` should looks like this if define a table named **tasks** and each row has **three columns**:

```ts
export type Database = {
  public: {
    Tables: {
      tasks: {
        Row: {  // the data expected from .select()
          completed: boolean | null
          id: string
          title: string
        }
        Insert: {  // the data to be passed to .insert()
          completed?: boolean | null
          id?: string
          title: string  // `not null` columns with no default must be supplied
        }
        Update: {  // the data to be passed to .update()
          completed?: boolean | null
          id?: string
          title?: string  // `not null` columns are optional on .update()
        }
        Relationships: []
      }
    }
  }
}
```



```ts
import { createClient } from "@supabase/supabase-js";
import { Database } from "../database.types";

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL as string;
const supabaseKey = process.env.EXPO_PUBLIC_SUPABASE_PUBLIC_KEY as string;

export const supabase = createClient<Database>(supabaseUrl, supabaseKey);
```



#### Supabase SQL Ops

```ts
import { supabase } from "@/utils/Supabase";

// Select
type Task = Database["public"]["Tables"]["tasks"]["Row"];

async function fetchTasks() {
  const { data, error } = await supabase.from("tasks").select("*");  // data is Task[] type

  if (error) {
    console.error("Error fetching tasks:", error);
    return [];
  }

  return data;
}

// Insert
type TaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];

async function addTask(newTask: TaskInsert) {
  const { error } = await supabase.from("tasks").insert(newTask);

  if (error) {
    console.error("Error adding task:", error);
  }
}
```

- Insert: `supabase.from("tasks").insert(newTask)`
- Fetch: `supabase.from("tasks").select("*")` or `supabase.from("tasks").select().eq("id", 1)`
- Update: `supabase.from("tasks").update({ title: "Updated Task"}).eq("id", 1)`
- Delete: `supabase.from("tasks").delete().eq("id", 1)`

Filters: [supabase.com/docs/reference/javascript/using-filter](https://supabase.com/docs/reference/javascript/using-filters)





### User Auth



#### Auth Ops JS API

```ts
// SignUp
const { data, error } = await supabase.auth.signUp({
  email: "student@example.com",
  password: "password123",
});

// SignIn
const { data, error } = await supabase.auth.signInWithPassword({
  email: "student@example.com",
  password: "password123",
});

// SignOut
const { error } = await supabase.auth.signOut();

// Check Current Session
const { data } = await supabase.auth.getSession();
const user = data.session?.user; // null if not logged in

// Subscribe to logging event change
supabase.auth.onAuthStateChange((_event, session) => {
  setUser(session?.user ?? null);
});
```



#### Example Code

````ts
import { useEffect, useState } from "react";
import { Button, TextInput, Text, View } from "react-native";
import { supabase } from "./utils/Supabase";

type User = {
  id: string;
  email?: string;
};

export default function App() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [user, setUser] = useState<User | null>(null);

  // Load session when app starts
  useEffect(() => {
    async function loadSession() {
      const { data } = await supabase.auth.getSession();
      setUser(data.session?.user ?? null);

      // Listen for login/logout events
      supabase.auth.onAuthStateChange((_event, session) => {
        setUser(session?.user ?? null);
      });
    }
    loadSession();
  }, []);

  // Sign up new user
  async function handleSignUp() {
    const { error } = await supabase.auth.signUp({ email, password });
    if (error) alert(error.message);
    else alert("Check your email for confirmation link (if enabled)");
  }

  // Sign in existing user
  async function handleSignIn() {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });
    if (error) alert(error.message);
  }

  // Sign out
  async function handleSignOut() {
    await supabase.auth.signOut();
  }

  return (
    <View>
      {user ? (
        <>
          <Text>Welcome, {user.email}</Text>
          <Button title="Sign Out" onPress={handleSignOut} />
        </>
      ) : (
        <>
          <TextInput
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
          />
          <TextInput
            placeholder="Password"
            value={password}
            onChangeText={setPassword}
            secureTextEntry
          />
          <Button title="Sign In" onPress={handleSignIn} />
          <Button title="Sign Up" onPress={handleSignUp} />
        </>
      )}
    </View>
  );
}
````





## Lecture 10: November 14, 2025

### EAS (Expo Application Service)

Build the app and deploy (submit) to apple store or google play

![eas](assets/eas.svg)

#### Expo EAS Build

Cloud service that compiles React Native App into installable native binaries

- iOS: `.ipa`
- Android: `.apk` or `.aab`

No local tools need to install

**Free tier**: 15 Android and 15 iOS builds/month



##### Setup 

Create an Expo account: [expo.dev/signup](https://expo.dev/signup)

```sh
npm install -g eas-cli     # Install EAS CLI
eas login                  # Log in to your Expo account
eas whoami                 # Verify login
```

Configure your iOS/Android project for EAS Build

```sh
eas build:configure        # Create a eas.json tells Expo how to build your app for a specific purpose
```

Example `eas.json`

```json
// Build Profiles
{
  "cli": {
    "version": ">= 16.26.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,   // Something
      "distribution": "internal"   // "internal" for internal testing, "store" for production release
    },
    "preview": {
      "distribution": "internal"   // "internal" for internal testing, "store" for production release
    },
    "production": {
      "autoIncrement": true        // Automatically increase version/build number for production builds
    }
  },
  "submit": {
    "production": {}
  }
}
```

- **development**: Fast builds for testing locally or on a few devices
- **preview**: Internal builds for sharing with teammates
- **production**: Final builds ready for App Store or Google Play

```sh
eas build --profile <profile-name> --platform <android|ios>

eas build --profile development --platform ios
```



If build **AAB** for Andriod:

```json
// eas.json
"production": {
  "gradleCommand": ":app:bundleRelease",
  "distribution": "store"
}
```

- `gradleCommand` specifies the Gradle (build system that Android uses to compile apps) task to run
  - `:app`: The `app` module in your Android project
  - `bundleRelease`: Build a release AAB for Google Play
  - `assembleRelease`: Build production APK for manual distribution

```sh
eas build --profile production --platform android

eas submit --platform android  # need to Create Google Play Console account
```



#### CI/CD

A software development practice to **automate** integration and delivery

**CI: Continuous Integration**

- Developers **commit code frequently**
- Each commit triggers **automatic build and test**
- Detects conflicts and errors early → smoother integration

**CD: Continuous Delivery / Continuous Deployment**

- **Continuous Delivery**: Automatically **package and prepare** tested code for release
  - Deployment to production still requires **manual approval**
- **Continuous Deployment**: Fully automated
  - New versions are **deployed to production automatically** once tests pass

##### via GitHub Actions

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Demo

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  ci:
    name: Continuous Integration
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - run: npm install
      - run: npm test

  cd:
    name: Continuous Deployment
    runs-on: ubuntu-latest
    needs: ci
    steps:
      - uses: actions/checkout@v4
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
```



##### via EAS Workflows

[official doc](https://docs.expo.dev/eas/workflows/get-started/)

```sh
# .eas/workflows/submit-ios.yml
on:
  push:
    branches: ['main']

jobs:
  build_ios:
    name: Build iOS app
    type: build
    params:
      platform: ios
      profile: production

  submit_ios:
    name: Submit to TestFlight
    needs: [build_ios]
    type: testflight
    params:
      build_id: ${{ needs.build_ios.outputs.build_id }}
```



```yaml
# .eas/workflows/submit-android.yml
on:
  push:
    branches: ['main']

jobs:
  build_android:
    name: Build Android app
    type: build
    params:
      platform: android
      profile: production

  submit_android:
    name: Submit to Google Play Store
    needs: [build_android]
    type: submit
    params:
      platform: android
      build_id: ${{ needs.build_android.outputs.build_id }}
```



#### EAS Update

Rollout small updates, adding an asset (image), JS. Update to the user next time when they open the app

1. Configure EAS Update

    ```sh
    eas update:configure
    ```

2. Update `app.json` with `runtimeVersion` and `updates.url` properties

    ```json
    // app.json
    "runtimeVersion": {
      "policy": "appVersion"
    }
    ```

    `"policy": "appVersion"`: Runtime version automatically matches app’s version (`expo.version` in `app.json`)

    - **Prevents incompatible updates**: If you release a new native build (e.g., adding a native module), devices running older builds won’t receive JS updates that depend on new native code

    `"policy": "1.0.1"`: Useful if you want more control over which builds receive updates

3. Update `eas.json` with setting the update `channel` property

    ```json
    // eas.json
    {
      "build": {
        "development": {
          "developmentClient": true,
          "distribution": "internal",
          "channel": "development"
        },
        "preview": {
          "distribution": "internal",
          "channel": "preview"
        },
        "production": {
          "autoIncrement": true,
          "channel": "production"
        }
      }
    }
    ```

4. Publish an update with `eas update`

    ```sh
    eas update --channel [channel-name] --message "[message]"
    ```

##### Limitations

Can **only update JavaScript and static assets**. 

Must rebuild with EAS Build and resubmit via EAS Submit if:

- Add a new native dependency (e.g., camera library)
- Change permissions, icons (native app’s metadata), etc.





# Course Summary

- **Styling and UI Design**: StyleSheet, Flexbox
- **Navigation**: React Navigation, Expo Router
- **State Management**: Context API, `useReducer`, Redux Toolkit
- **Data Persistence**: React Native Async Storage
- **Notifications**: Local notifications, push notifications
- **Backend Integration**: Supabase
- **User Authentication**: Supabase
- **Deployment**: Expo Application Services (EAS)





